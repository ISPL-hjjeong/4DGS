# 격자 꼭짓점 Feature 상세 설명

## 🎯 핵심 개념

각 격자 꼭짓점에는 **32차원의 feature 벡터**가 저장되어 있습니다. 이 feature들은 모델의 학습 가능한 파라미터이며, 학습을 통해 최적화됩니다.

---

## 1️⃣ 형상 (Shape)

### 전체 그리드의 Shape

```python
# 예: xy 평면 (해상도 레벨 1, resolution=[64, 64, 64, 25])
grid_shape = [1, 32, 64, 64]
#            │  │   │   └─ x축 해상도 (64개 격자점)
#            │  │   └───── y축 해상도 (64개 격자점)
#            │  └───────── feature 차원 (32차원)
#            └──────────── batch 차원 (항상 1)
```

### 각 격자 꼭짓점의 Feature Shape

```python
# 특정 격자 꼭짓점 (y=10, x=20)의 feature
vertex_feature = grid[0, :, 10, 20]  # [32]
# → 32차원 벡터
```

**비유:**
- 전체 그리드는 **32개의 채널을 가진 64×64 이미지**와 같습니다
- 각 픽셀(격자 꼭짓점)이 32차원의 정보를 담고 있습니다

---

## 2️⃣ 생성 과정

### 단계별 생성 과정

#### **1단계: 메모리 할당**

```python
new_grid_coef = nn.Parameter(torch.empty(
    [1, out_dim] + [reso[cc] for cc in coo_comb[::-1]]
))
# 예: xy 평면, out_dim=32, reso=[64, 64, 64, 25]
# → [1, 32, 64, 64]
```

**무엇을 하는가?**
- `torch.empty()`는 메모리 공간만 할당합니다
- 이 시점의 값들은 **무작위적인 쓰레기 값**입니다
- 아직 의미 있는 값이 아닙니다

**예시 (쓰레기 값):**
```python
# torch.empty() 직후 (실제로는 무작위 값)
grid[0, :, 10, 20] = [0.0001, -0.0003, 0.0002, ..., 0.0005]  # 의미 없음
```

#### **2단계: 초기화**

초기화 방식은 평면의 종류에 따라 다릅니다:

**A. 시간 평면 (xt, yt, zt)**

```python
if has_time_planes and 3 in coo_comb:  # 3은 시간 차원 인덱스
    nn.init.ones_(new_grid_coef)  # 모든 값을 1.0으로 초기화
```

**결과:**
- 모든 격자 꼭짓점의 feature가 `[1.0, 1.0, 1.0, ..., 1.0]` (32개 모두 1.0)

**예시:**
```python
# xt 평면의 격자 꼭짓점 (t=5, x=10)
grid[0, :, 5, 10] = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                     1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                     1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                     1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
# 모든 값이 1.0
```

**왜 1.0으로 초기화?**
- 시간 변화가 없을 때는 변형이 없어야 하므로
- 곱셈 결합에서 1.0은 "변화 없음"을 의미합니다
- 학습을 통해 시간에 따른 변화를 학습합니다

**B. 공간 평면 (xy, xz, yz)**

```python
else:
    nn.init.uniform_(new_grid_coef, a=0.1, b=0.5)
    # 0.1에서 0.5 사이의 균일 분포에서 무작위로 샘플링
```

**결과:**
- 각 격자 꼭짓점의 feature가 `0.1`에서 `0.5` 사이의 무작위 값으로 초기화됩니다

**예시:**
```python
# xy 평면의 격자 꼭짓점 (y=10, x=20)
grid[0, :, 10, 20] = [0.32, 0.15, 0.48, 0.21, 0.39, 0.12, 0.45, 0.28,
                      0.17, 0.43, 0.31, 0.24, 0.36, 0.19, 0.41, 0.27,
                      0.14, 0.38, 0.22, 0.46, 0.33, 0.18, 0.44, 0.29,
                      0.16, 0.42, 0.25, 0.37, 0.20, 0.40, 0.23, 0.35]
# 각 값이 0.1~0.5 사이의 무작위 값
```

**왜 0.1~0.5로 초기화?**
- 작은 값으로 초기화하여 학습 초기에 안정적이도록 합니다
- 다양한 초기값을 제공하여 학습이 빠르게 시작되도록 합니다

---

## 3️⃣ 구체적인 예시 값

### 예시 1: xy 평면 (해상도 레벨 1)

**그리드 Shape:** `[1, 32, 64, 64]`

**격자 꼭짓점 예시:**

```python
# 격자 꼭짓점 (y=0, x=0) - 왼쪽 위 모서리
grid[0, :, 0, 0] = [
    0.32, 0.15, 0.48, 0.21, 0.39, 0.12, 0.45, 0.28,
    0.17, 0.43, 0.31, 0.24, 0.36, 0.19, 0.41, 0.27,
    0.14, 0.38, 0.22, 0.46, 0.33, 0.18, 0.44, 0.29,
    0.16, 0.42, 0.25, 0.37, 0.20, 0.40, 0.23, 0.35
]
# Shape: [32]

# 격자 꼭짓점 (y=32, x=32) - 중앙
grid[0, :, 32, 32] = [
    0.28, 0.41, 0.19, 0.36, 0.24, 0.31, 0.43, 0.17,
    0.27, 0.45, 0.12, 0.39, 0.21, 0.48, 0.15, 0.32,
    0.35, 0.23, 0.40, 0.20, 0.37, 0.25, 0.42, 0.16,
    0.29, 0.44, 0.18, 0.33, 0.46, 0.22, 0.38, 0.14
]
# Shape: [32] (다른 무작위 값)

# 격자 꼭짓점 (y=63, x=63) - 오른쪽 아래 모서리
grid[0, :, 63, 63] = [
    0.23, 0.40, 0.20, 0.37, 0.25, 0.42, 0.16, 0.29,
    0.44, 0.18, 0.33, 0.46, 0.22, 0.38, 0.14, 0.35,
    0.32, 0.15, 0.48, 0.21, 0.39, 0.12, 0.45, 0.28,
    0.17, 0.43, 0.31, 0.24, 0.36, 0.19, 0.41, 0.27
]
# Shape: [32] (또 다른 무작위 값)
```

**총 격자 꼭짓점 수:**
- 64 × 64 = 4,096개
- 각각 32차원 feature를 가짐
- 총 파라미터 수: 4,096 × 32 = 131,072개

---

### 예시 2: xt 평면 (시간 평면)

**그리드 Shape:** `[1, 32, 25, 64]`
- t축: 25개 격자점
- x축: 64개 격자점

**격자 꼭짓점 예시:**

```python
# 격자 꼭짓점 (t=0, x=0) - 초기 시간, 왼쪽
grid[0, :, 0, 0] = [
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
]
# 모든 값이 1.0

# 격자 꼭짓점 (t=12, x=32) - 중간 시간, 중앙
grid[0, :, 12, 32] = [
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
]
# 모든 값이 1.0 (초기화 시점)

# 격자 꼭짓점 (t=24, x=63) - 마지막 시간, 오른쪽
grid[0, :, 24, 63] = [
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0
]
# 모든 값이 1.0 (초기화 시점)
```

**총 격자 꼭짓점 수:**
- 25 × 64 = 1,600개
- 각각 32차원 feature를 가짐 (모두 1.0으로 초기화)
- 총 파라미터 수: 1,600 × 32 = 51,200개

---

## 4️⃣ 학습을 통한 변화

### 초기화 시점 vs 학습 후

**초기화 시점 (xy 평면 예시):**
```python
# 격자 꼭짓점 (y=10, x=20)
initial_feature = [
    0.32, 0.15, 0.48, 0.21, 0.39, 0.12, 0.45, 0.28,
    0.17, 0.43, 0.31, 0.24, 0.36, 0.19, 0.41, 0.27,
    0.14, 0.38, 0.22, 0.46, 0.33, 0.18, 0.44, 0.29,
    0.16, 0.42, 0.25, 0.37, 0.20, 0.40, 0.23, 0.35
]
# 0.1~0.5 사이의 무작위 값
```

**학습 후 (예시):**
```python
# 같은 격자 꼭짓점 (y=10, x=20)
learned_feature = [
    0.85, 0.12, 1.23, -0.45, 0.67, 0.91, -0.18, 0.34,
    0.56, -0.23, 0.78, 0.41, 0.92, -0.15, 0.63, 0.28,
    -0.37, 0.49, 0.81, -0.52, 0.14, 0.73, -0.29, 0.46,
    0.58, -0.41, 0.95, 0.17, 0.62, -0.33, 0.79, 0.25
]
# 학습을 통해 최적화된 값 (범위도 다양해짐)
```

**변화 이유:**
- `nn.Parameter`로 정의되어 있어 학습 가능한 파라미터입니다
- 역전파(backpropagation)를 통해 지속적으로 업데이트됩니다
- 씬의 4D 특징을 표현하기 위해 최적화됩니다

---

## 5️⃣ 전체 구조 요약

### 하나의 해상도 레벨에서

```
해상도 레벨 1 (res=1):
  ├─ xy 평면: [1, 32, 64, 64]
  │   └─ 4,096개 격자 꼭짓점
  │       └─ 각각 32차원 feature (0.1~0.5 무작위 초기화)
  │
  ├─ xz 평면: [1, 32, 64, 64]
  │   └─ 4,096개 격자 꼭짓점
  │       └─ 각각 32차원 feature (0.1~0.5 무작위 초기화)
  │
  ├─ xt 평면: [1, 32, 25, 64]
  │   └─ 1,600개 격자 꼭짓점
  │       └─ 각각 32차원 feature (모두 1.0 초기화)
  │
  ├─ yz 평면: [1, 32, 64, 64]
  │   └─ 4,096개 격자 꼭짓점
  │       └─ 각각 32차원 feature (0.1~0.5 무작위 초기화)
  │
  ├─ yt 평면: [1, 32, 25, 64]
  │   └─ 1,600개 격자 꼭짓점
  │       └─ 각각 32차원 feature (모두 1.0 초기화)
  │
  └─ zt 평면: [1, 32, 25, 64]
      └─ 1,600개 격자 꼭짓점
          └─ 각각 32차원 feature (모두 1.0 초기화)
```

---

## 🔑 핵심 포인트 요약

1. **형상**: 각 격자 꼭짓점은 **32차원 벡터**를 가집니다
2. **생성**: `torch.empty()`로 메모리 할당 → 초기화 함수로 값 설정
3. **초기화**:
   - 시간 평면: 모든 값이 **1.0**
   - 공간 평면: **0.1~0.5** 사이의 무작위 값
4. **학습**: `nn.Parameter`로 정의되어 학습을 통해 최적화됩니다
5. **용도**: Bilinear Interpolation에서 이 feature들을 가중 평균하여 새로운 위치의 feature를 계산합니다

